<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Boarding Ride Details</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            height: 100vh;
            width: 100vw;
        }

        /* Back Button */
        .back-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            background: white;
            border: none;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 20px;
            z-index: 1000;
        }

        .back-btn:hover {
            background: #f0f0f0;
        }
    </style>
</head>

<body>
    <!-- Back Button -->
    <button class="back-btn" onclick="window.history.back()">←</button>

    <div id="map"></div>
    <button id="markCompletedBtn" style="background:#d32f2f;color:white;padding:10px 20px;border:none;
           border-radius:8px;cursor:pointer;position:absolute;top:15px;left:50%;
           transform:translateX(-50%);z-index:1000;">
        Mark as Completed
    </button>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const urlParams = new URLSearchParams(window.location.search);
            const rideId = urlParams.get('ride_id');
            if (!rideId) {
                alert('No ride_id provided.');
                return;
            }

            // Fetch ride details and boarding points in parallel
            Promise.all([
                fetch(`http://localhost:3000/api/ride-details?ride_id=${rideId}`).then(res => res.json()),
                fetch(`http://localhost:3000/api/boarding-points?ride_id=${rideId}`).then(res => res.json())
            ]).then(([ride, boardingPoints]) => {
                // Initialize map WITHOUT zoom control
                const map = L.map('map', { zoomControl: false });

                L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '© OpenStreetMap'
                }).addTo(map);

                // Draw route polyline
                const polyline = JSON.parse(ride.route_polyline);
                const routeLayer = L.polyline(polyline, { color: 'black' }).addTo(map);
                map.fitBounds(routeLayer.getBounds());

                // Start and end markers
                const greenDotIcon = L.divIcon({
                    html: '<div style="background-color:green;width:18px;height:18px;border-radius:50%;border:2px solid #fff;"></div>',
                    className: '',
                    iconSize: [18, 18],
                    iconAnchor: [9, 9]
                });

                L.marker([ride.start_lat, ride.start_lng], { icon: greenDotIcon })
                    .addTo(map)
                    .bindPopup('Source');

                L.marker([ride.end_lat, ride.end_lng])
                    .addTo(map)
                    .bindPopup('Destination');

                // Show passenger details in popup
                boardingPoints.forEach(bp => {
                    L.marker([bp.boarding_lat, bp.boarding_lng], {
                        icon: L.divIcon({
                            className: 'boarding-point-marker',
                            html: '<div style="background-color:blue;width:18px;height:18px;border-radius:50%;border:2px solid #fff;"></div>'
                        })
                    }).addTo(map).bindPopup(
                        `<b>Passenger:</b> ${bp.passenger_name || 'N/A'}<br>
             <b>Phone:</b> ${bp.passenger_phone || 'N/A'}`
                    );
                });

                // Driver marker logic with dynamic rotation
                let driverMarker = null;
                let lastDriverLatLng = null;

                function calculateBearing(lat1, lng1, lat2, lng2) {
                    const toRad = deg => deg * Math.PI / 180;
                    const toDeg = rad => rad * 180 / Math.PI;

                    const dLon = toRad(lng2 - lng1);
                    lat1 = toRad(lat1);
                    lat2 = toRad(lat2);

                    const y = Math.sin(dLon) * Math.cos(lat2);
                    const x = Math.cos(lat1) * Math.sin(lat2) -
                        Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
                    let brng = Math.atan2(y, x);
                    brng = toDeg(brng);
                    return (brng + 360) % 360;
                }

                function updateDriverMarker(lat, lng) {
                    let rotation = -45; // default
                    if (lastDriverLatLng) {
                        rotation = calculateBearing(lastDriverLatLng[0], lastDriverLatLng[1], lat, lng);
                    }
                    lastDriverLatLng = [lat, lng];

                    if (!driverMarker) {
                        driverMarker = L.marker([lat, lng], {
                            icon: L.divIcon({
                                className: '',
                                html: `<div style="transform: rotate(${rotation}deg); color: #0066ff; font-size: 32px;">➤</div>`,
                                iconSize: [45, 45],
                                iconAnchor: [16, 16]
                            })
                        }).addTo(map).bindPopup('Driver Location');
                    } else {
                        driverMarker.setLatLng([lat, lng]);
                        driverMarker.setIcon(L.divIcon({
                            className: '',
                            html: `<div style="transform: rotate(${rotation}deg); color: #0066ff; font-size: 32px;">➤</div>`,
                            iconSize: [45, 45],
                            iconAnchor: [16, 16]
                        }));
                    }
                }

                // Poll every 5 seconds
                setInterval(() => {
                    fetch(`http://localhost:3000/api/ride-location?ride_id=${rideId}`)
                        .then(res => res.json())
                        .then(loc => {
                            if (loc.current_lat && loc.current_lng) {
                                updateDriverMarker(loc.current_lat, loc.current_lng);
                            }
                        });
                }, 5000);

            }).catch(err => {
                alert('Failed to load ride or boarding points.');
                console.error(err);
            });
        });

        document.getElementById('markCompletedBtn').onclick = function () {
            const urlParams = new URLSearchParams(window.location.search);
            const rideId = urlParams.get('ride_id');
            if (!rideId) {
                alert('No ride_id provided.');
                return;
            }

            if (confirm('Are you sure you want to mark this ride as completed?')) {
                fetch(`http://localhost:3000/api/ride/${rideId}`, { method: 'DELETE' })
                    .then(res => res.json())
                    .then(data => {
                        alert('Ride marked as completed and removed.');
                        window.location.href = 'my_rides.html';
                    })
                    .catch(err => alert('Failed to mark ride as completed.'));
            }
        };
    </script>
</body>

</html>